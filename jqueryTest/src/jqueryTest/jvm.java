package jqueryTest;

public class jvm {

	/**
	 *   标题  jvm 内存管理讲解
	 *   在java中 我们基本不会显示的调用分配内存的函数，我们甚至不用关系到底那些指令需要分配内存的方法，那些不许要，在java中
	 *   分配内存和回收内存都有jvm自动完成
	 *   
	 *   我们不会太关系程序到底是怎么使用内存的，使用了多少内存，当我们真的了解java的是如何管理内存的时候，当我们遇到真的outofmemoryerror
	 *   的时候不会奇怪地问为什么java也会有内存泄露，什么地方导致的，可以通过日志来快速的定位错误
	 *   谈到内存我们要先搞懂java使用的运行内存与物理内存有什么关系，所谓的物理内存就是我们常说的ram随机存储器，还有一个存储单元叫做寄存器
	 *   寄存器的作用：用于存储计算单元值执行指令（浮点，整数等运算时）的中间结果，寄存器的大小决定了一次计算课使用的最大数值
	 *   在window还是linux下 我们要运行程序，都要向系统先申请内存地址，通常操作系统管理内存是按照进程来管理的，每个进程拥有一段
	 *   独立的地址空间，每个进程之间不会相互重合，操作系统也会保证每个进程只能访问自己的内存空间，上诉所谓的内存空间是指逻辑上的独立，这个独立是由
	 *   操作系统来控制的，但是真正的内存空间是不是只能由一个进程来使用就不一定了，随着程序的越来越大这种情况就有了虚拟内存的出现。
	 *   
	 *   虚拟内存的出现可以使得多个进程在同时运行时共享物理内存，只是空间共享，在逻辑上任然是不能相互访问的 
	 *   
	 *   
	 *   
	 *   java启动后也可以作为一个进程在操作系统中，那么这个进程有哪些部分需要分配内存呢？
	 *   
	 *   ① java堆  -- java堆适用于存储对象的内存区域，堆的大小在jvm启动时就一次的向操作系统申请完成，通过-xmx,-xms
	 *   xmx表示堆的最大大小，xms表示初始大小，一旦分配完成，堆的大小就将固定，不能再内存不够时再向操作系统重新申请，同时当内存空间
	 *   空闲时也不能将多余的空间交还给操作系统
	 *   
	 *   ② 线程 jvm运行实体是线程当然线程需要内存空间来存储一些必要的数据，每个线程创建时jvm都会为它创建一个堆栈，堆栈的大小根据jvm实现
	 *   而不同通常在256kb---756kb之间，线程所占的空间相比堆空间来说比较小，如果线程过多，线程堆栈的总内存使用量可能非常大，当前有很多的
	 *   程序更具cpu的核数来分配创建线程数
	 *   
	 *   
	 *   ③ 类和类的加载器
	 *   在java中类和类的加载器同样需要存储空间，在sun  JDK中他们也被存储在堆中这个区域叫做永久代（PermGen区）
	 *   需要注意一点jvm是需要来加载类的，在这里解决大家一个问题：jvm加载一个jar包是否把这个jar包中的所有类都加在到内存中？ 显然不是的
	 *   jvm只会加载那些你在应用程序中明确使用的类的内存中，如果你要查看jvm到底加载了那些类，可以在启动参数上加上-verbose：class
	 *   
	 *   ④ Nio 在javaJDK以后添加i/o类库引入了一种基于通道和缓冲区来执行i/o的新方式  
	 *   ⑤ JNI JNI技术可以使得本机的代码可以调试java程序，也就是通常所说的native memory  
	 *   
	 *   
	 *   
	 *   
	 *   jvm 内存结构
	 *   
	 *   jvm是按照运行时数据的存储结构来划分内存结构的，jvm在运行java程序时，将他们划分成几种不同格式的数据，分别存储在不同的区域中，这些数据
	 *   统称为运行的数据 运行时的数据包括java本身的数据信息和jvm运行java程序需要的而外数据信息，如记录当前的程序命令指针
	 *   
	 *   
	 *   
	 *   
	 *   在java虚拟机中规范将java运行时的数据划分为六种：
	 *   
	 *   
	 *   一：pc寄存器数据  
	 *   pc寄存器严格来说是一个数据结构，他用于保存当前正常执行的程序内存地址。同时java程序是多线程来执行的所以不可能一直都按照
	 *   线性执行下去 当有多个线程交叉执行时，被中断的线程当前执行到那条内存地址必然要保存下来 以便于 他被恢复执行时在按照被中断时的指令地址继续执行下去
	 *   比如： 一个记事员一样记录下哪个线程当前执行到哪条指令   
	 *   
	 *   java栈
	 *   
	 *   java栈总是和线程关联在一起的，每当创建一个线程时 jvm就会为这个线程来创建一个对应的java栈 在这个java栈中又会包含多个栈帧
	 *   这些栈帧是与每个方法关联起来的 ，每次运行一个方法就会创建一个栈帧  每个栈帧会含有一些内部变量（在方法内定义的变量） ，操作栈和方法 
	 *	  当一个方法执行完时 这个栈帧就会弹出栈帧的元素作为这个方法的返回值 并清除这个栈帧 java栈的栈顶的栈帧就是当前正在执行的活动栈 也就是当
	 *  前正在执行的方法 pc寄存器也会指向这个地址  只有这个活动的栈帧的本地变量可以被操作栈使用 当前这个栈帧调用另一个方法时 与之对应的一个新的栈帧
	 *  又被创建 这个新的创建栈帧又被放到java栈的顶部 变为当前活动的栈帧 同样现在只有这个栈帧的本地变量才能被使用，当前这个栈帧的所有命令执行完成时
	 *  这个栈帧就会被移除java栈 刚才的那个栈帧就又变成活跃的了 前面的栈帧的返回值又变成这个栈帧的操作栈中的一个操作数 如果前面的栈帧没有返回值
	 *  那么当前的栈帧的操作栈的操作数没有什么变化
	 *  由于java栈是与java线程对应起来的 这个数据不是线程共享的 所以我们不用关系他的数据一致性的问题 也不会存在同步锁的问题 
	 *  
	 *   堆
	 *   堆是存储java对象的地方 他是jvm管理java对象的核心存储区域 堆是java程序员最应该关注的地方 每一个存储在堆中的java对象都是这个
	 *   对象的类的一个副本 他会复制包括继承自它父类的所有非静态属性 堆是被所有java线程所共享的 所以对它的访问需要注意同步的问题 方法和属性都属要
	 *   保证一致性
	 *   
	 *   
	 *   
	 *   方法区
	 *   jvm方法区 适用于存储类结构信息的地方  一个class文件解析成jvm能识别的几个部分 这些不同的部分在这个class被加载jvm时 会被存储在不同的
	 *   数据结构中 其中常量池 域 方法数据 方法体 构造函数 包括类中专用方法 实例初始化 接口初始化都存储在这个区域 这个方法区也属于 java堆中的 永久区
	 *   这个区域可以被所有线程共享 并且他的大小可以通过参数来设置
	 *   
	 *   本地方法栈
	 *   本地方法栈 是为jvm 运行native方法准备的空间 
	 *   
	 *   运行时常量池
	 *   runtime constant pool 代表运行时每个class文件中的常量表 
	 *   
	 *   
	 *   （当JVM栈的空间不足时，会抛出StackOverflowError的错误，在Sun JDK中可以通过-Xss来指定栈的大小）
	 *   当堆中需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。
	 *   
	 *   Xms和-Xmx来控制，-Xms为JVM启动时申请的最小Heap内存，默认为物理内存的1/64但小于1G
	 *   
	 *   
	 *   每一个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中,并由应用所有的线程共享.跟C/C++不同，Java中分配堆内存是自动初始化的。Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配,
	 *   也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。
	 *   
	 *   http://developer.51cto.com/art/201303/387175.htm
	 */
}
